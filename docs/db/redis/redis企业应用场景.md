## Redis 企业应用场景

## 一 短信登录

基于Redis实现共享session登录

* 选择合适的数据结构
* 选择合适的key
* 选择合适的存储粒度

## 二 数据缓存

### 2.1 缓存更新策略

* 内存淘汰：利用Redis内置的内存淘汰机制，当内存不足时自动淘汰部分数据，下次查询时更新数据。
* 超时剔除：给数据添加TTL时间，到期后自动删除。
* 主动更新：编写代码，修改数据的时候同时更新缓存。

![](https://kaliarch-bucket-1251990360.cos.ap-beijing.myqcloud.com/blog_img/20220403220617.png)

先操作数据库，再删缓存。

![](https://kaliarch-bucket-1251990360.cos.ap-beijing.myqcloud.com/blog_img/20220403221022.png)

### 2.2 缓存问题

#### 2.2.1 缓存穿透

* 概念

客户端请求的数据的数据不在数据库中，这样缓存永远也不能生效，请求一直到数据库层，一般可能是黑客攻击。

* 解决方案
  * 缓存空对象：实现简单，维护方便，但有额外的内存消耗，可能短时间数据不一致。
  * 布隆过滤器：根据算法缓存索引，如果不存在则不存在，返回存储也有一定程度不存在的可能，内存占用小，没有对于的key，存在误判
  * 增加ID的复杂度，避免被猜到ID的规律。
  * 做好数据的基础校验。
  * 用户权限。
  * 热点参数的限流。

#### 2.2.2 缓存雪崩

* 概念

同一时刻存在大量的key同事失效或redis宕机，导致大量请求到达数据库。

* 解决方案
  * 给不同的key的ttl添加随机值
  * 利用redis集群提升高可用性
  * 给缓存业务添加降级限流策略
  * 给业务添加多级缓存

#### 2.3 缓存击穿

* 概念

缓存击穿问题也称为热点key问题，一个被高并发访问并且缓存重建业务较复杂的key突然失效，无数的请求访问会瞬间给数据库带来巨大压力。

* 解决方案
  * 互斥锁
  * 逻辑过期

![](https://kaliarch-bucket-1251990360.cos.ap-beijing.myqcloud.com/blog_img/20220403223238.png)

## 三 消息队列实现秒杀

### 3.1 全局唯一ID生成策略

* UUID
* Redis自增
* snowflake算法
* 数据库自增

### 3.2 并发线程安全

![](https://kaliarch-bucket-1251990360.cos.ap-beijing.myqcloud.com/blog_img/20220404165748.png)

### 3.3 乐观锁

* 版本法
* CAS法：基于数据逻辑进行判断。

## 四 分布式锁

多进程可见，并且互斥的锁

### 4.1 特征

* 多进程可见
* 互斥
* 高可用
* 高性能
* 安全性

### 4.2 实现分布式锁

* 获取锁
  * 互斥：确保只有一个线程获取锁（set nx ex，获取锁的时候存入线程ID）

* 释放锁
  * 手动释放：释放的时候判断是否与当前线程ID一致，如果不一致则不释放。
  * 超时释放：获取锁时添加超时时间

![](https://kaliarch-bucket-1251990360.cos.ap-beijing.myqcloud.com/blog_img/20220404180424.png)